/**
 * A HTML Template include simple HSP sub-template
 */
Aria.classDefinition({
    $classpath : "bridge.aria.widget.Bridge",
    $extends : "aria.widgetLibs.BaseWidget",
    $dependencies : ["bridge.aria.widget.BridgeCfg", "aria.templates.TemplateTrait", "aria.utils.Html",
             "aria.utils.Dom"],
    $events : {
        "ElementReady" : {
            description : "Raised when the template content is fully displayed."
        }
    },
    $statics : {
        ERROR_SUBTEMPLATE : "#ERROR IN SUBTEMPLATE#"
    },
    /**
     * Create an instance of the widget.
     * @param {bridge.aria.widget.BridgeCfg:Properties} cfg widget configuration, which is the parameter given in the
     * template
     * @param {aria.templates.TemplateCtxt} context template context
     */
    $constructor : function (cfg, ctxt) {
        this.$BaseWidget.constructor.apply(this, arguments);

        /**
         * Creates a unique id to be used in the markup generated by the widget.
         * @return {String}
         */
        this._domId = !cfg.id ? this._createDynamicId() : this._context.$getId(cfg.id);

        /**
         * Configuration which will be sent to the template context. It is initialized with some properties in the
         * template widget constructor and completed later. It is set to null just after the template context has been
         * initialized, or if an error prevents the template from being loaded. So, if it is not null, we are still
         * waiting for the template to be loaded.
         * @protected
         * @type bridge.aria.widget.BridgeCfg
         */
        var hsp = cfg.hsp;
        this._tplcfg = {
            hsp : hsp.src,
            args : hsp.args,
            id : this._domId
        };

        // does the normalization
        this._checkCfgConsistency(cfg);
    },

    $destructor : function () {
        this.tplInstance.$dispose();
        this.$BaseWidget.$destructor.call(this);
    },
    $prototype : {
        $init : function (p) {
            var src = aria.templates.TemplateTrait.prototype;
            for (var key in src) {
                if (src.hasOwnProperty(key) && !p.hasOwnProperty(key)) {
                    // copy methods which are not already on this object (this avoids copying $classpath and
                    // $destructor)
                    p[key] = src[key];
                }
            }
        },

        /**
         * Internal function called before markup generation to check the widget configuration consistency
         */
        _checkCfgConsistency : function (cfg) {
            var jsonValidator = aria.core.JsonValidator;
            this._cfgOk = jsonValidator.validateCfg("bridge.aria.widget.BridgeCfg.Properties", cfg);
        },

        /**
         * Initialize the template widget when DOM is available. As this widget has _directInit it gets initialized soon
         * after the markup is added to the DOM.
         * @protected
         */
        initWidget : function () {
            bridge.aria.widget.Bridge.superclass.initWidget.call(this);
            var tplDiv = aria.utils.Dom.getElementById(this._domId);
            //tplDiv.className = tplDiv.className + " " + this._cssClassNames;
            var args = this._tplcfg.args;
            var hspTemplate = this._tplcfg.hsp;
            this.tplInstance = hspTemplate.apply(hspTemplate, args)
            this.tplInstance.render(tplDiv);
        },

        /**
         * Write in the output buffer the markup for a template widget. Since the template classpath might not be loaded
         * yet, this function is asynchronous. If the template is not loaded yet it will write a placeholder, otherwise
         * the template content
         * @param {aria.templates.MarkupWriter} out Markup Writer
         * @protected
         */
        writeMarkup : function (out) {
            if (this._cfgOk) {
                var tplcfg = this._tplcfg;
                if (this._tplcfg) {
                    var tagName = this._cfg.type;
                    var markup = ['<', tagName, ' id="', this._domId, '"'];
                    if (this._cfg.attributes) {
                        markup.push(' ' + aria.utils.Html.buildAttributeList(this._cfg.attributes));
                    }
                    markup.push('>');
                    markup.push('</' + tagName + '>');
                    out.write(markup.join(''));
                } else {
                    out.write("<div>" + this.ERROR_SUBTEMPLATE + "</div>");
                }
            }
        },

        /**
         * Return the id of the widget, if it should be referenced from the template scripts or other widgets.<br />
         * In this case do not return dynamic ids, as they don't need to be checked for unicity and they are not known
         * outside the widget
         * @return {String} id of the widget, as specified in the config
         * @override
         */
        getId : function () {
            return this._cfg.id;
        }
    }
});
